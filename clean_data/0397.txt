Shadow Blade: A tool to interact with attack vectors Ariel R. Ril1, Daniel Dalalana Bertoglio2 and Avelino F. Zorzo3 Pontifical Catholic University of Rio Grande do Sul School of Technology Porto Alegre, Brazil ariel.ril@edu.pucrs.br1, daniel.bertoglio@edu.pucrs.br2 and avelino.zorzo@pucrs.br3 Abstract—The increased demand of cyber security profession- als has also increased the development of new platforms and tools that help those professionals to improve their offensive skills. One of these platforms is HackTheBox, an online cyber security training platform that delivers a controlled and safe environment for those professionals to explore virtual machines in a Capture the Flag (CTF) competition style. Most of the tools used in a CTF, or even on real-world Penetration Testing (Pentest), were developed for specific reasons so each tool usually has different input and output formats. These different formats make it hard for cyber security professionals and CTF competitors to develop an attack graph. In order to help cyber security professionals and CTF competitors to discover, select and exploit an attack vector, this paper presents Shadow Blade, a tool to aid users to interact with their attack vectors. Index Terms—capture the flag, cyber security, HackTheBox, attack graph I. INTRODUCTION Computer technology has been spread throughout all areas in modern society. This wide spread use has brought many advantages to people, helping to improve the productivity of their activities. Despite all these advantages, this new environment has also increased the number of virtual attacks that are being deployed in the Digital World. In order to reduce the impact of these attacks, new skills to Information Technology (IT) professionals are needed. These skills are related to understand the types of attacks that may affect people in real life. Two main types of skill can be described as defensive and offensive. In the former, a “reactive approach to security that focuses on prevention, detection, and response to attacks” is used. In the latter, “a proactive approach to security through the use of ethical hacking” is applied [33]. This paper is related to the offensive strategy. In the cyber security universe there are many ways to sharpen the offensive skills [1] and one of these ways is a Capture The Flag (CTF) Competition [22]. The CTF Com- petition objective is to find flags (pieces of data) that are inside specially crafted virtual machines (VM). These VMs are developed with selected vulnerabilities so the competitors can explore and exploit these vulnerabilities to access the VM and steal those flags. In the processes of exploring a machine in a CTF, the competitor must use a comprehensive list of tools for recon- naissance (e.g., nmap [24], ffuf [14]), vulnerability assessment (searchsploit [12]) and exploitation (metasploit [23]). But for the competitors to reach the exploitation step, they have to create an artifact from the previous steps to be able to create an attack graph, which will be used to filter and select the best attack vector to be followed in order to compromise the machine. The attack graph is the data structure used to represent all possible attacks on a computer network, in which one or more attack vectors will be selected to successfully exploit a target. Most of the tools that are used during a CTF, or even in the real-world for a Penetration Testing (Pentest) [4], were created for a specific purpose. Hence, each tool usually has different input and output formats. These different formats of generated data make it hard for the CTF competitors and cyber security professionals to compile and analyze the data and develop the artifact that is needed to select the best attack vector. Therefore, in order to help cyber security professionals and CTF competitors to discover, select and exploit an attack vector, this paper presents Shadow Blade, a tool to aid users to interact with their attack vectors. Shadow Blade is a tool that can help users by running reconnaissance tools (nmap and ffuf, initially) and develop a visualization of attack vectors in the intended target using directed graphs. This paper is organized as follows. In Section II we present the background for this work. Section III presents the related work. Section IV describes our proposal. Section V describes similar tools and compares them with Shadow Blade. Section VI presents some preliminary evaluation of our tool. And, finally, Section VII and Section VIII present our conclusions and future work. II. BACKGROUND In this section we present some topics that are related to our proposal. Initially, in Section II-A, we define what are attack graphs and attack vectors. Afterwards, in Section II-B, we describe how a CTF works. In Section II-C we describe how HackTheBox, the platform that we tested Shadow Blade, works. Finally, in Section II-D we define the base structure that Shadow Blade uses. A. Attack Graph & Attack Vectors An attack graph is the data structure used to represent all possible attacks on a network [30] and can be formally defined as: Definition II.1. An attack graph (AG) is a tuple G = (S, τ, S0, Ss), where S is a set of states, τ ⊆S × S is a arXiv:2401.01960v1 [cs.CR] 3 Jan 2024 Figure 1. Shadow Blade architecture transition relation, S0 ⊆S is a set of initial states, and Ss ⊆S is a set of success states. An attack vector is a sequence of actions or techniques that could compromise a machine, an enterprise or a computer network. Attack vectors are a subset of an attack graph. B. Capture the Flag (CTF) A Capture the Flag (CTF) Competition is, usually, an online competition where the competitors have a list of vulnerable virtual machines, which are created to be intentionally ex- ploited so the competitors can improve their offensive skills. The objective of a CTF is to compromise the bigger number of machines as possible, exploiting their vulnerabilities to retrieve flags (pieces of data or random strings) that are hidden in the machine. C. HackTheBox (HTB) HackTheBox [19] is an online cyber security training plat- form that presents a long list of vulnerable machines, a list of security challenges and real-world scenarios so their users can always improve their security skills. Each vulnerable machine in the platform is categorized using a difficulty level that can be easy, medium, hard or insane. An easy machine at HTB commonly has a very explicit attack vector, so less experienced users can learn the basics of cyber security and the basics of offensive skills. Nonetheless, an insane machine is closest to a real-world scenario that could be an enterprise application that was almost cleared of vulnerabilities, but using a complex attack graph is still possible to compromise it. D. Directed Graph A directed graph [6] is a graph made of a set of vertices con- nected with directed edges. Formally defined as G = (V, E) where: • V is a set of vertices, nodes or points • E is a set of ordered pair of vertices, which define the start and end of an edge III. RELATED WORK Obes, Sarrute & Richarte [26] developed a tool that receive as input a computer network definition and executes a planning process using Planning Domain Definition Language (PDDL) and uses SGPlan [7] and Metric-FF [20] as planners to evaluate the PDDL plan. PDDL is used to define the actions that need to be executed (exploit execution, reconnaissance, ...) and to identify the final goal, which is to fully compromising the computer network achieving the highest access level. Therefore, it is possible to verify the possibility to automate all exploration process in a computer network. Nonetheless, despite the fact that it was used in a realistic computer network, this approach has an exponential complexity growth directly proportional to the number of hosts in the network. The complexity growth is due to each new machine in the network have a connection to all previous machines, so the planner has to evaluate all the new paths for possible vulnerabilities. Amman & Pamula [3] approached this problem using a simplified definition for the planner execution and the au- tomation of the exploration process. This simplification was in the execution of the automated exploration. The developed algorithm analyses only the connections from the current machine to decide which plan to execute, it is not necessary to analyse the complete network. Therefore, this simplified approach implies that the protective measures to mitigate the security issues against machine exploitation are sub-optimal. IV. PROPOSAL: SHADOW BLADE In this paper we discuss Shadow Blade, a tool to interact with attack vectors that is a modular tool developed to help cyber security professionals and CTF competitors on executing reconnaissance tools (nmap or ffuf, in the first version) and afterwards create a visualization with directed graphs of the attack vectors that were found. This section presents the architecture and development decisions of Shadow Blade. A. Architecture The Shadow Blade architecture follows the Domain-Driven Design (DDD) [11]. In DDD each component is defined based in a domain, which could be defined as a context that the component will have knowledge of. Each component, or module, of Shadow Blade executes only one functionality in order to allow the possibility of replacing a complete module without harming the whole system. The developed modules for this first version can be visualized in Figure 1: • Weight: An API that given a graph can compute the weight of each edge and returns the result; • Code Runner: A fac¸ade [15] API for Linux Shell [17]; • Graph: An API that manages the data of an attack graph using Neo4j [18], a graph database; • Orchestrator: A fac¸ade for all raw functionality of Shadow Blade; • UI: A React [28] app that the user can interact with and view results from nmap and ffuf Different languages were used to develop each module. The language choice was based on each use case, so it could be flexible to expand and easy enough to understand the project organization. B. Weight The Weight API was developed using Go [31], a language whose format is similar to a low level programming language, but it has high level programming languages constructs. Go is expressive, concise, clean, and efficient [9]. For the HTTP request handling, the Gin Web framework [16] was used. Gin is one of the most popular web frameworks for Go, it is fast, modular and it has the ability to add middleware in the process of handling a request to apply a functionality to all or some HTTP endpoints. C. Code Runner This module was developed using Go and Gin, but it has the ability to transform an HTTP request into commands for a Linux Shell. The first version of our tool uses nmap [24] and ffuf [14]. The reason for that is because nmap is one of the main tools for network scanning and ffuf is able to perform a series of web scanning varying from path discovery to API fuzzing. D. Graph The Graph module was developed using Typescript [32], a variation of JavaScript that is typed. The choice of Typescript was because the language forces the type definition and this definitions lower the possibility to have some type related bug in the program. ExpressJS [13] was chosen to be the web application framework because it is easy to setup, easy to understand and modular. This is the main module of the project because it holds the information of the attack graph in a Neo4j [18] database: a database that is designed to save the data as nodes and edges. We chose Neo4j because the application result produce a directed graph in which nodes represent network ports or HTTP endpoints and edges contain the probability that a step from and to a node would have when an attack path could be exploited. E. Orchestrator This module coordinates the actions selected by the user in the user interface (UI). The Orchestrator was develop with NodeJS [25] using ExpressJS as the web framework and it is mainly divided into target and graph. The target resource will Figure 2. BloodHound showing the connections of objects in an Active Directory be the machine that the user is exploring in a CTF and the graph will be the attack graph generated from the output of execution of the tools implemented in the Code Runner (see Section IV-C). F. User Interface (UI) This is the user interface where the user can register a new target in the platform and execute actions against the target to start the exploration process and receive a visual feedback that is the generated attack graph. The implementation of the module uses ReactJS [28], which is a declarative library used to develop frontend applications using a component based approach. V. SIMILAR TOOLS The cyber security community has developed some tools that creates a visualization of a computer network using data generated from previous scans. Maltego [21] that ”is an open source intelligence and graphical analysis tool for gathering and connecting information for investigative tasks” generates a visualization of a computer network using information obtained from different reconnaissance sources, which can overwhelm the user with information. On the other hand Shadow Blade generates a simplified directed graph, so the user can learn from the information gathered in Shadow Blade and create its own directed graph. BloodHound [5] gathers information from an Active Direc- tory (AD) [2] and generates a directed graph of the connections of each object in the AD. In Figure 2 we show BloodHound is used to extract information from an AD. The main difference from BloodHound to Shadow Blade is that Shadow Blade generates an attack graph with information of any computer network while BloodHound can only be used with an AD. VI. EVALUATION To evaluate if Shadow Blade would help cyber security professionals and CTF competitors to execute reconnaissance tools, gather the output data and create a visualization of attack vectors, we used an out-of-use machine in HackTheBox (HTB). The choice of that machine in HTB was that out-of- use machines have walk through on how to explore and exploit Figure 3. Registering Armageddon machine in Shadow Blade Figure 4. Selection of nmap options these machines and compare the results obtained in Shadow Blade with the actual attack vector of the machine. The chosen machine for the evaluation was the out-of-use machine Armageddon, which is rated as easy in the platform. This machine has a vulnerable Drupal CMS [10] - a content management system - that is vulnerable to Remote Code Execution (RCE) [8], popularly called Drupalgeddon. After initializing all Shadow Blade modules the user can access the UI and start registering the intended target. To register a new target the user can use the target IP or a custom host pre-configured on the user machine. The process of registering a new target is showed in Figure 3, in the example we used a custom host for Armageddon (armageddon.htb). With the target registered, a user can start the reconnaissance processes executing nmap to discover the open ports of the machine and what services are running in each port. For this, the user can use the ”Run Nmap scan on Target” button and select which nmap options to use (Figure 4). For this project we enabled some nmap options: • Banner grabbing: is the process to connect to a certain port in a machine and retrieve the banner (data) that the service executing in the port returns to any attempt of connection; • Hosts online: nmap has the ability to connect to a ma- chine port and verify whether the port is online (returning information of a successful connection), or the port is filtered (the machine is behind a firewall and the firewall is dropping the attempts to connect in a port), or the port is closed; • Default scripts: with the port number and the banner information, nmap can select default scripts that the community developed and execute against the machine. Usually these scripts are used for identification of vul- nerable services and service default configuration. As shown in Figure 5, ports 22 and 80 in the Armageddon Figure 5. Result of executing nmap against Armageddon from HTB Figure 6. Options to execute ffuf machine are open: in port 80, an Apache server version 2.4.6 in a CentOS is running; and in port 22, OpenSSH 7.4 is running. With this information, the user can click in the Apache node and select some options to execute ffuf on port 80 of the machine. Clicking in the Apache node will render a window with the options to execute ffuf, which are shown in Figure 6. In this example we configured two options to execute ffuf: to follow redirects and remove all “HTTP Status Code returns 403” (forbidden) results. The options developed for this project were: • Path recursion: ffuf will execute a recursion in the folders that it finds. For example, if a web server returns that the path ”/js” exists than ffuf will attempt to find more directories or files in the path ”/js/”, recursively; • Follow redirect: ffuf will follow the 301 HTTP Status Code, which defines a redirect from the current web page, sending the user the a new location; • Ignore HTTP Status Code: ffuf will ignore every HTTP response that have the Status Code present in the configured list. Figure 7 shows the result of executing ffuf in port 80 of Armageddon. The result shows a list of paths that are Figure 7. Result attack graph from executing ffuf in port 80 from Armageddon accessible and this information will help the user to decide if it is necessary to execute ffuf in some new path, or if it is time to use an external tool to continue the exploration of the service. VII. CONCLUSION In this paper we discussed Shadow Blade: a tool to interact with attack graphs [29]. This tool can help cyber security professionals and CTF competitors to execute reconnaissance tools, gather the output data and generate an attack graph in order to show the possible attack vectors that the user can explore. We focused on the presentation of the tool showing that the tool was developed to be used in a real-world scenario and we beta tested it in a CTF example, which is a small and custom computer network. We also discussed related work of tools that automated all the process of reconnaissance, vulnerability discovery and exploitation of real life computer networks, which could be developed inside Shadow Blade using its modular components. Shadow Blade was not developed to automate all the re- connaissance, vulnerability analysis and exploitation process, so the cyber security professionals and CTF competitors can sharpen their offensive skills. Therefore, Shadow Blade can perform some automated tasks for reconnaissance to increase the speed on common tasks. On the other hand, we developed Shadow Blade to be modular enough that cyber security professionals and CTF competitors can develop new functionalities that have a better fit for their workflow. Hence, the general idea is that the user can use Shadow Blade to execute common reconnaissance tasks for an initial analysis and afterwards execute more specialized tools outside, creating new nodes in Shadow Blade to represent the result of the specialized tools. VIII. FUTURE WORK We expect to expand the Weight module to receive a graph and execute the computation of the weights inside a planner and, probably, add some type of machine learning so that Shadow Blade can learn how to better compute the weight of the edges and propose a better attack graph for the user. Another improvement would be to add more tools in Code Runner so that the user can execute as much tools as it is possible via Shadow Blade, so it can generate a more precise attack graph for the user. Furthermore, in Section II we presented an initial formal- ization that could be used to better describe our work in a formal way, similar to the work of Peralta et al. [27]. REFERENCES [1] 15 Cybersecurity Resources to Build Your Skills — CompTIA. URL: https : / / www . comptia . org / blog / cybersecurity- resources- to- build- your- skills (visited on 11/21/2021). [2] Active Directory. URL: https://en.wikipedia.org/wiki/ Active Directory (visited on 12/15/2021). [3] P. Ammann et al. “A host-based approach to network attack chaining analysis”. In: 21st Annual Computer Security Applications Conference (ACSAC’05). 2005, 10 pp.–84. [4] Daniel D. Bertoglio and Avelino F. Zorzo. “Overview and open issues on penetration test”. In: Journal of the Brazilian Computer Society 23 (Dec. 2017). [5] BloodHoundAD/BloodHound: Six Degrees of Domain Admin. URL: https : / / github . com / BloodHoundAD / BloodHound (visited on 12/15/2021). [6] J.A. Bondy and U.S.R Murty. Graph Theory. 1st. Springer Publishing Company, Incorporated, 2008. [7] Yixin Chen, Benjamin W. Wah, and Chih-Wei Hsu. “Temporal Planning Using Subgoal Partitioning and Resolution in SGPlan”. In: Journal of Artificial Intelli- gence Research 26.1 (Aug. 2006), pp. 323–369. [8] CVE - CVE-2018-7600. URL: https://cve.mitre.org/cgi- bin/cvename.cgi?name=cve- 2018- 7600 (visited on 11/18/2021). [9] Documentation - The Go Programming Language. URL: https://golang.org/doc/ (visited on 11/18/2021). [10] Drupal - Open Source CMS — Drupal.org. URL: https: //www.drupal.org/ (visited on 11/18/2021). [11] Eric Evans. Domain-Driven Design: Tackling Complex- ity in the Heart of Software. Addison-Wesley, 2004. [12] Exploit Database SearchSploit Manual. URL: https : / / www . exploit - db . com / searchsploit (visited on 11/03/2021). [13] Express - Node.js web application framework. URL: https://expressjs.com (visited on 11/18/2021). [14] Ffuf/ffuf: Fast web fuzzer written in Go. URL: https: //github.com/ffuf/ffuf (visited on 11/03/2021). [15] Erich Gamma et al. Design Patterns: Elements of Reusable Object-Oriented Software. 1st ed. Addison- Wesley Professional, 1994. [16] Gin Web Framework. URL: https : / / gin - gonic . com/ (visited on 11/18/2021). [17] P GNU. Free Software Foundation. Bash (3.2. 48)[Unix shell program]. 2007. [18] Graph Data Platform — Graph Database Management System — Neo4j. URL: https://neo4j.com/ (visited on 11/03/2021). [19] Hack The Box. URL: https://app.hackthebox.eu/ (visited on 09/10/2021). [20] Jorg Hoffmann. “Extending FF to Numerical State Vari- ables”. In: Proceedings of the 15th European Confer- ence on Artificial Intelligence. ECAI’02. Lyon, France: IOS Press, 2002, pp. 571–575. [21] Maltego. URL: https://www.maltego.com/ (visited on 12/15/2021). [22] Lucas McDaniel, Erik Talvi, and Brian Hay. “Capture the Flag as Cyber Security Introduction”. In: 2016 49th Hawaii International Conference on System Sciences (HICSS). 2016, pp. 5479–5486. [23] Metasploit — Penetration Testing Software, Pen Testing Security — Metasploit. URL: https://www.metasploit. com/ (visited on 11/03/2021). [24] Nmap: the Network Mapper - Free Security Scanner. URL: https://nmap.org/ (visited on 11/03/2021). [25] Node.js. URL: https : / / nodejs . org / en/ (visited on 09/10/2021). [26] Jorge Luc´angeli Obes, Carlos Sarraute, and Gerardo Richarte. “Attack Planning in the Real World”. In: Computing Research Repository abs/1306.4044 (2013). arXiv: 1306.4044. URL: http://arxiv.org/abs/1306.4044. [27] Karine P Peralta et al. “Specifying security aspects in UML models”. In: ACM/IEEE 11th International Conference on Model Driven Engineering Languages and Systems. 2008. [28] React – A JavaScript library for building user inter- faces. URL: https://reactjs.org (visited on 09/10/2021). [29] Ariel R. Ril. shdw: Shadow Blade - A Capture the Flag Tool. URL: https://github.com/arielril/shdw (visited on 11/18/2021). [30] O. Sheyner et al. “Automated generation and analysis of attack graphs”. In: Proceedings 2002 IEEE Symposium on Security and Privacy. 2002, pp. 273–284. DOI: 10. 1109/SECPRI.2002.1004377. [31] The Go Programming Language. URL: https://golang. org (visited on 09/10/2021). [32] TypeScript: JavaScript With Syntax For Types. URL: https://www.typescriptlang.org (visited on 09/10/2021). [33] What are General, Defensive, and Offensive Cybersecu- rity Tracks? URL: https://online.maryville.edu/online- bachelors-degrees/cyber-security/understanding-cyber- security-tracks/ (visited on 11/21/2021).
AutoCRAT: Automatic Cumulative Reconstruction of Alert Trees Eric Ficke1[0000−0002−3762−6475], Raymond M. Bateman2[0000−0002−2949−5145], and Shouhuai Xu3[0000−0001−8034−0942] 1 The University of Texas at San Antonio, San Antonio, TX, USA 2 U.S. Army Research Laboratory South - Cyber, San Antonio, TX, USA 3 University of Colorado Colorado Springs, Colorado Springs, CO, USA Abstract. When a network is attacked, cyber defenders need to pre- cisely identify which systems (i.e., computers or devices) were compro- mised and what damage may have been inflicted. This process is some- times referred to as cyber triage and is an important part of the incident response procedure. Cyber triage is challenging because the impacts of a network breach can be far-reaching with unpredictable consequences. This highlights the importance of automating this process. In this pa- per we propose AutoCRAT, a system for quantifying the breadth and severity of threats posed by a network exposure, and for prioritizing cy- ber triage activities during incident response. Specifically, AutoCRAT automatically reconstructs what we call alert trees, which track network security events emanating from, or leading to, a particular computer on the network. We validate the usefulness of AutoCRAT using a real-world dataset. Experimental results show that our prototype system can recon- struct alert trees efficiently and can facilitate data visualization in both incident response and threat intelligence analysis. Keywords: Cyber Triage · Alert Tree · Alert Path · Threat Score · Alert Pri- oritization · Incident Response · Intrusion Detection · Cyber Attack 1 Introduction In cyber incident response, the defender needs to precisely identify what hap- pened to the network in question, including: how did the attacker propagate through the network, what was the attacker’s intent, and where and how much damage did the attacker inflict? Since attackers may target a large portion of a network, the defender must quickly and effectively determine the scope of their impact. Specifically, the defender must isolate the routes that the attacker may have used to enter and propagate through the network. These are referred to as alert paths, and may be aggregated into so-called alert trees. Isolating alert paths turns out to be a difficult task for two reasons. First, for any amount of incoming alerts, the number of paths that need to be ex- amined grows quadratically. This is the problem of efficiency. Second, without arXiv:2409.10828v1 [cs.CR] 17 Sep 2024 examining all possible alert paths, it is possible that the defender will overlook the actual attack path. This is the problem of coverage, which is closely related to false negatives in intrusion detection systems. These problems have serious implications on incident response, as the average time to contain threats can be as high as 85 days [50]. The same report suggests that security automation can reduce this by 26% (to 63 days). In order to help defenders effectively and effi- ciently respond to cyber incidents, the research community needs to investigate principled solutions to tackling this problem. This motivates the present study, which aims to facilitate cyber triage by automatically identifying the potential scope of an attack. Our Contributions. In this paper, we make three contributions. First, we for- malize a suite of concepts to automate cyber triage, including: alert graph, which presents a Graph-Theoretic representation of alerts triggered on a network; alert path, which indicates a sequence of potentially-related attack steps across multi- ple computers; alert tree, which represents a set of attack paths (as identified by alerts) with respect to a computer of interest. These concepts allow us to rep- resent alerts in a structural fashion to facilitate various analysis and reasoning cyber triage tasks of interest. Second, we present a novel system called AutoCRAT to reconstruct alert trees from the output of a Network Intrusion Detection System (NIDS). Au- toCRAT’s key features can be characterized as follows. (i) It can continuously process streams of alerts reported by security devices. This is important for real-world usage where security devices constantly produce alerts. (ii) It can quickly reconstruct alert trees on demand. Our asymptotic analysis shows that in the worst-case scenario, graph maintenance scales cubically with the number of alerts, while tree reconstruction scales quadratically or log-linearly, depending on the type of tree. (iii) It can model multi-step attacks, which include lateral movements secondary to a compromise. This is important because attacker ob- jectives often cannot be accomplished after a single compromise. (iv) It can model muti-target attacks, in which a single attacker produces multiple attack paths with different targets. This is important because it does not require the assumption that an attacker has a single target. (v) It can model multi-source attacks, in which a single victim is targeted by different attackers or by an at- tacker with multiple access points. This is important because it does not require the assumption that only a single attacker is active on the network. Third, we demonstrate the usefulness of alert trees and the alert tree recon- struction method by conducting a case study using a dataset which is collected from a realistic cyber attack testbed, namely CSE-CIC-IDS2018, as published by the University of New Brunswick’s Canadian Institute for Cybersecurity. Our experimental results show that our methods were able to analyze the data within the timeframe during which the data was collected, while also incorporating a larger portion of the data than previous works. Related Work. We divide related prior studies into four categories: attack modeling, attack reconstruction, alert prioritization, and intrusion detection. In terms of attack modeling, the problem has been approached using alert correla- tion [22,70] and clustering [13]. The present study moves a step further by making sense of alerts through the notion of alert paths, which are more comprehensive than alert correlation because they explicitly model temporal-spatial relation- ships. This means they may be useful in mapping the attack to a particular model (e.g., [28,37,52]), which may accommodate explicit happens-before dependencies. Similarly, attack paths (not to be confused with alert paths) have been studied for their usefulness in predicting attack outcomes [8,25,6,46,40,41,26]. These are distinct from alert paths, which are instead retrospective in nature and based on observed attacker activity rather than potential vulnerabilities. Attack graphs have also been used to model the potential propagation of attacks through a com- puter network [42,12,31,30,27,21]. Like attack paths, attack graphs are focused on static network evaluation or attack prediction, rather than reconstruction of observed attack patterns. In terms of attack reconstruction for multi-step attacks, one work that recon- structs multi-step attacks is MAAC [56]. This model assumes a four-stage attack model, where steps of an attack operation can only be assembled if stage 3 alerts are found. This means that false negatives in alert production are more likely to produce false negatives in the model. Although MAAC assembles an alert graph, it only identifies paths of length one, which is likely an attack step within a host rather than across hosts. Another reconstruction method is MIF [38], which uses supervised machine learning to reduce graph size and then produces a risk-state graph to track network attacks. Edges are ordered by start times only, which may induce false positives when two paths overlap. The model uses a recursive depth-first-traversal to build paths. On LLDoS 2000 (containing 60 hosts), MIF processes one million (upsampled) flows in 3m24s. It processed CICIDS2017 for accuracy but did not give runtimes. Yet another reconstruction method is APIN [19], which builds an alert graph using raw alerts and extracts alert paths with respect to a particular node using a chronological traversal. It includes complex- ity analysis and runtimes for the DARPA 1999 intrusion detection evaluation dataset and the CSE-CIC-IDS2018 dataset. In terms of alert prioritization, the concept of alert trees benefits from rele- vant studies of alert prioritization [3,48,4,17]. This process ranks alerts according to their severity or associated risk. These rankings are useful to constructing alert trees because they enable more intuitive tree interpretation. For example, visu- alizing the colors of nodes in a tree based on the ranking (i.e., prioritization) can help defenders identify hotspots in the network. An innovative method is presented in [17] to achieve better visualization of alert tress. In terms of intrusion detection, alert trees depend on input from intru- sion detection systems (IDSs), including network-based (NIDS) and host-based (HIDS). IDSs have been criticised heavily on account of the base-rate fallacy, poorly-representative environments, limited attack scope, and weak ground truth [5,54,55,11]. IDSs are ineffective in practice because of alert volumes, false posi- tives and alert interpretability [20,18,16,29]. Paper Outline. Section 2 formalizes the problem. Section 3 presents Auto- CRAT. Section 4 presents the results of applying AutoCRAT to a dataset. Sec- tion 5 discusses limitations of AutoCRAT. Section 6 concludes the paper. Table 1 summarizes common terms used in the paper and shows the symbols used to represent them. Term Symbol Meaning / Usage Alert/Arc α ∈A (or A) Event indicating the presence of an attack. By convention, A denotes the set of all alerts in a dataset, while A ⊆A. Alert Graph G(A) The set of vertices, arcs, maps and labels used to model a set of alerts representing network attacks. Endpoint pair e ∈E The ordered pair (source, destination), which is used to group certain sets of arcs. Alert Path p ∈P(A) A sequence of vertices and accompanying arc sets derived from G(A) with partial happens-before ordering. Origin vp 1 First node in a path p Target vp n Last node in a path p of length n Alert Tree Tfwd(A, ˆv), Tbwd(A, ˆv) An aggregation of alert paths with common origin or target, respectively. Threat Score TS(A), ETS(e), PTS(p) Metric used to rank sets of alerts by relative threat to the network. Also used for endpoints and paths, respectively. AutoCRAT The proposed model for tracking network events. Table 1. Common terms and symbols used throughout the paper 2 Problem Statement Informal Problem Statement. Consider an enterprise network, which con- sists of computer systems and security devices (e.g., NIDSs), and is managed by the defender. Note that the concept of an enterprise network is generally appli- cable to many types of computer networks, including IoT networks and mobile networks. Computers on the enterprise network may be the target of cyber at- tacks from some attacker, which may come from inside or outside the network. Network traffic is monitored by security devices, which produce alerts when an attack is observed by a security device. A successful attacker may conduct sec- ondary attacks (known as lateral movements) against other computers within the network. The term multi-step attack refers to such a sequence of attacks. We aim to develop an understanding of multi-step attacks against a network. This leads to three informal questions: (i) What routes could an attacker have taken to get from one computer to another? (ii) What is the scope of a given attack operation, as represented by an alert or group of alerts? (iii) How may the attacker have used lateral movements to traverse the network and finally set up a particular attack? To answer them, we first need to formalize them. Formalization: Alert and Alert Graph / Path / Tree. We begin with the input of a stream of alerts, denoted by A, generated by network security / defense devices (e.g., NIDSs). Definition 1 (Alert). An alert α is generated by a network security device corresponding to a communication between a source computer and a destination computer and can be described as a tuple α = (source, destination, time, ID), where source and destination are the endpoints of the alert, time represents the timestamp at which the communication begins, and ID is the alert identifier given by the security device (e.g., signature identifier or remote logon type). Having defined alerts, we construct more complex objects, namely alert graphs, alert paths and alert trees. Given a set of alerts, we can construct an alert graph, a labeled multidigraph where multiple arcs may exist between a pair of nodes (e.g., an attack may make multiple connections before it succeeds, resulting in multiple arcs). Moreover, vertices and arcs can have common labels because alert (i.e., arc) IDs belong to a pre-defined set with specific cybersecurity meanings. Definition 2 (Alert Graph). Given a set of alerts A, an alert graph is a la- beled multidigraph G(A) = (ΣV , ΣA, V, A, s, t, ℓV , ℓID, ℓtime), where vertex v ∈V represents a computer on the network, arc a ∈A represents an alert produced by a security device, ΣV denotes the set of computer labels (such as IP addresses), ΣA denotes the set of alert labels (i.e., α’s ID), s : A →V maps arcs to their source vertex (i.e., α.source), t : A →V maps arcs to their target vertex (i.e., α.destination), ℓV : V →ΣV maps vertices to their labels, ℓID : A →ΣA maps arcs to their alert labels, and ℓtime : A →N maps alerts to the set of natural numbers, representing the time at which they occurred. Given an alert graph G(A), the concept of alert path describes a sequence of vertices through which an attack is observed (as indicated by alerts). Since alerts representing a multi-step attack may consist of multiple repeated arcs between a pair of vertices, a path is associated with a set of arcs where multiple arcs may link the same pair of vertices. This arc set is further divided into a sequence of smaller arc sets, grouped by the endpoints corresponding to pairs of vertices in the path. Within these arc sets, there must be a valid sequence of arcs, one each from consecutive arc sets, such that they appear in chronological order. Definition 3 (Alert Path). Given an alert graph G(A), an alert path is de- fined as p = (V p, Ap), where V p = (vp 1, . . . , vp n) is a sequence of unique vertices in V ; Ap is a corresponding set of arcs in A, for which there must exist a sequence of arc sets (Ap 1, . . . , Ap n−1) such that Ap i = {α ∈A : s(α) = vp i ∧t(α) = vp i+1}, and Ap = Sn−1 i=1 Ap i , and there must exist some sequence (α1, . . . , αn−1) such that for each i ∈[1, . . . , n −1], αi ∈Ap i ∧i < n −1 →ℓtime(αi) < ℓtime(αi+1). Given an alert path p with V p = (vp 1, . . . , vp n), we say vp 1 is the origin and vp n is the target. Given A, let P(A) denote the set of all alert paths in G(A). A path p ∈P(A) may be uniquely identified by V p. An alert tree represents a set of alert paths P(A) (where A ⊆A) with a common reference vertex, which is either the origin or the target, but not both. Trees with a common origin are called forward trees and trees with a common target are called backward trees, because of the happens-before relationship of alerts in the tree. Because the graph G(A) is a labeled multidigraph, it is possible that cyclical subgraphs will result in sets of paths P(A) such that they cannot naturally be combined to form trees. For example, the graph constructed from the set of paths P = {(a, b, c), (a, c, b)} contains a cycle (b, c, b) and is therefore not a tree. However, if we manipulate the set of paths by changing duplicate nodes into unique nodes with the same identifier (in ΣV ), we can artificially prevent this loop formation. Consider the previous example. We can change the second path to (a, c′, b′) such that ℓV (c′) = ℓV (c) and ℓV (b′) = ℓV (b). This results in a tree with arcs (a, b), (b, c), (a, c′), (c′, b′) such that the modified graph forms a tree, which can be used to extract the relevant computer identifiers. The advantage of the tree structure over an arbitrary graph is that one can visualize the temporal dependence of the arcs based on their height within the tree. Since temporal dependence is an important feature of alert paths, it is natural to visualize sets of alert paths using alert trees rather than alert graphs. Definition 4 (Alert Tree). Given an alert graph G(A), a reference vertex ˆv ∈V , and a set of paths P ′ = {p ∈P(A) : vp 1 = ˆv}, a forward alert tree is a labeled digraph denoted Tfwd(A, ˆv) = {ΣV,T , VT , AT , ℓV,T }, where ΣV,T = V , VT = V × P ′,AT = (v, v′) ∈VT such that ∃p ∈P ′, i ∈[1, . . . , |V p|] for which v = vp i ∧v′ = vp i+1, and ℓV,T : VT →ΣV,T maps vertices to their corresponding nodes in V . A forward alert tree is rooted at reference vertex ˆv and represents paths p ∈P ′, such that every vertex in p has a corresponding vertex v ∈VT for which all of the ascendants of v (denoted asc(v)) are labeled with the vertices in the path. Specifically, ∀i ∈[1, . . . , |asc(v)|], ℓV,T (asc(v)i) = vp i . A backward alert tree Tbwd is a reversed forward tree in the following sense: reference vertex ˆv is the target rather than the origin of all of the corresponding alert paths, while the vertex identifiers must match vertex descendants rather than ascendants. Equipped with the preceding definitions, we can now formalize the afore- mentioned informal questions as the following research questions (RQs). – RQ1: This question asks for the set of all alert paths with a specified origin and target. Formally, given a set of alerts A, a known attack origin vorigin, and a known attack target vtarget, produce the set of attack paths P ′ = {p ∈ P(A) : vp 1 = vorigin ∧vp |V p| = vtarget}. – RQ2: This question asks for the depth and breadth of access that an at- tacker achieved corresponding to an alert (or attack). Formally, given a set of alerts A and a known attack origin vorigin, produce the forward alert tree Tfwd(A, vorigin). – RQ3: This question asks for the set of multi-stage attacks that may have led to the compromise of a computer. Formally, given a set of alerts A and a known attack target vtarget, produce the backward alert tree Tbwd(A, vtarget). 3 The AutoCRAT System Here we propose the AutoCRAT system to address the RQs mentioned above. Figure 1 highlights its architecture, which has two main components: database and core functions. The system receives inputs in the form of management and data retrieval, which make calls to the core functions to change or retrieve data from the database, respectively. This section discusses the database and core functions of AutoCRAT. Database Update (as needed) Query Update Query Threat Calculation Alert Feed Security Device Graph/Path Maintenance Update (continuous) Management Outputs Path Query Query Path Retrieval Return Exposure Paths Return Exposure Trees Tree Query Query Tree Construction Data Retrieval Paths Arcs Indexes: -Source -Destination -ETS Indexes: -Origin -Target -Nodes -Edges -PTS -Children Core Retrieve Retrieve & Merge Reinsert Alert Reinsertion Update (as needed) Fig. 1. Architecture of the AutoCRAT system 3.1 Database The database stores the arcs (i.e., alerts) and paths derived from G as follows. First, the arc collection of the database stores pairs of arc endpoints. Arcs are stored as annotations to the arc endpoints. This enables more efficient retrieval of alerts, which are always considered in the context of the other alerts with the same endpoints. Second, alert paths are stored in their own collection. Each path p ∈P(A) contains a list of nodes, the corresponding node pairs (to facilitate retrieval via pairwise indexing), the path’s PTS, and a list of child vertices (denoted Childrenp) that have been used to produce lengthened copies of the path, {v ∈V : (∃p′ ∈P(A), ∀vp i ∈V p)vp i = vp′ i ∧|V p′| = |V p| + 1 ∧v = vp′ |V p′|}. This list is used to facilitate path validation, as discussed later in this section. Every time a path is lengthened, the new path is added as its own object in the database, in order to facilitate indexing as described below. Indexing. Each collection is indexed so that its objects may be efficiently found and retrieved from the database. Our approach uses multiple types of indices, including individual indexes (on a single field), compound indexes (on two or more fields) and multikey indexes (on a set or sequence). Some of these index types are only available in certain kinds of databases, such as MongoDB, which is used in our implementation. This limits the interoperability of our approach, or risks compromising the efficiency of accessing some objects in the database. The arc collection is indexed by arc endpoints (each individually as well as together in a compound index), and by the arc’s threat score (discussed later in this section). The path collection has individual indices on the origin, the target, and the path’s threat score (also discussed later). It also has multikey indexes on the vertex sequence and the arc endpoint sequence. Additionally, the path collection has one compound index, covering the target and the list of child vertices (as a multikey index). Duplicate paths are prevented by validating new arcs against this list of children in the path’s so-called parent (i.e., p′ ∈P such that V p′ = V p−(vp |V p|)∧ vp |V p| ∈Childrenp′. Subpaths are stored as their own objects because this allows them to be more efficiently indexed. Specifically, we index the path’s origin and target, because multikey indexes do not preserve order. This means that, if a multikey index was used on the path nodes, then an attempt to retrieve paths with a certain origin and target would need to parse all paths containing both the origin and target in any position, then trim the path appropriately. In this case, the runtime optimization of multikey indexing of path vertices trades off with storage complexity (i.e., storing more paths). On the other hand, it is efficient to use a multikey index to index to children of a particular path, because queries that search for children need only find a single child (i.e., the destination of the alert being inserted). This means that the ordering of children in a multikey index is unimportant. 3.2 Core The core has five modules: alert graph / path maintenance, reinsertion, threat calculation, path retrieval, and tree construction. These modules are invoked by the respective management services. Algorithm 1 Alert Graph / Path Maintenance Input: α, G(A) = (ΣV , ΣA, V, A, s, t, ℓV , ℓID, ℓtime), P, Childrenp∈P Output: G(A ∪{α}), P, Childrenp∈P 1: if ̸ ∃α′ ∈A : s(α) = s(α′) ∧t(α) = t(α′) then 2: V ˆ p ←(s(α), t(α)) ▷Create ˆp via V ˆ p 3: Childrenˆ p ←∅ 4: P ←P ∪{ˆp} 5: end if 6: A ←A ∪{α} 7: V ←V ∪{s(α), t(α)} 8: Candidate_P aths ←{p ∈P : V p |V p| = s(α)} ▷Find paths to lengthen using “end” index 9: for c ∈Candidate_P aths do 10: if t(α) ̸∈V c then ▷Prohibit cycles 11: if t(α) ̸∈Childrenc then ▷Prohibit identical twins 12: p′ ←{V c, Ac} 13: V p′ ←V p′ ∪(t(α)) 14: Ap′ ←Ap′ ∪{α} 15: Childrenp′ ←∅ 16: Childrenc ←Childrenc ∪{t(α)} 17: P ←P ∪{p′} 18: end if 19: end if 20: end for 21: return G = (V, A), P, Childrenp∈P Core Module 1: Alert Graph / Path Maintenance. As new security events arrive, AutoCRAT incorporates them into the relevant databases according to Algorithm 1, which proceeds as follows: (i) It first checks if the new arc includes existing endpoints. If so, it adds the arc to the endpoint object as an annotation; otherwise, it inserts a new endpoint object annotated with the arc (Lines 1-13). (ii) It queries the database to find paths which end at the source of the event (Line 14). (iii) The algorithm copies the paths found, appending the alert’s destination onto the copies. If the new paths already exist in the database or are cyclical, they are discarded. The original paths are annotated with a list of children to facilitate this check on future inserts, and the new paths are inserted (Lines 15-27). In the worst-case scenario, every insertion of a new alert α will add a new endpoint object and path, and lengthen the set of existing paths that termi- nate at the source of the inserted arc. This will give us a storage complexity in O(|E|+|A|+|P|). Now suppose one inserts the first arc, with endpoints (v1, v2), into a database. This will produce a single path: (v1, v2). A second insertion of (v2, v3) adds a new path and lengthens the existing path, resulting in three paths: (v1, v2), (v2, v3), and (v1, v2, v3). Clearly, each arc adds at most one new endpoint object (exactly one in this case), leading to |E| or O(|A|). This means that each new arc adds up to |E| new paths of length |E| or less, leading to |P| ∈O(|A|2). This is demonstrated in Table 2. Arcs 1 2 3 4 |A| Endpoint pairs 1 2 3 4 |A| Paths 1 3 6 10 P|A| i=1(i) Table 2. The worst-case storage complexity after i arc insertions. As each new arc αi can add as many as i paths, the worst-case number of paths is |P| = 1 2|A|2 + 1 2|A| or O(|A|2). Under the same worst-case scenario, the insert algorithm must access every path in the database, |P|, copy each, adding one endpoint, and insert the copies, plus one new path with two nodes. Then the worst-case runtime (in terms of the number of accesses to the database) is 2 · |P| + 1 or O(|P|). Core Module 2: Reinsertion. In some cases, the defender may need to find paths that were unavailable at the time of data collection (e.g., if the NIDS produces a false negative which is later corrected). Since alerts are otherwise inserted chronologically, we need another algorithm to perform such retroactive insertions (“reinsert”). For this purpose we propose Algorithm 2. The storage complexity is the same as for the regular maintenance function, O(|A|2). The asymptotic runtime is dominated by |ppre| · |ppost|. Because cycles about α are removed (lines 2,4), P pre ∩P post = ∅. This is bounded by (δ · |P|) · ((1 −δ) · |P|), where δ < 1 is the proportion of the larger of the two path sets relative to |P|. This simplifies to (δ −δ2) · |P|2, for which the maximum value of the first term (when δ = 1 2) is 1 4. The worst-case runtime is 1 4|P|2 or O(|P|2). Core Module 3: Threat Calculation. We propose measuring a given set of alerts A ⊂A according to its threat score (TS), which can also be used during alert visualization. For example, nodes in a graph may be colored from black to red based on their TS in ascending order, to guide the viewer to network hotspots. We use this approach in our examples to follow. Algorithm 2 Alert Reinsertion Input: α, G(A), P Output: G(A ∪{α}), P 1: P pre ←{p ∈P : V p |V p| = s(α)} 2: P pre ←P pre \ {p ∈P pre : t(α) ∈V p} 3: P post ←{p ∈P : V p 1 = t(α)} 4: P post ←P post \ {p ∈P post : s(α) ∈V p} 5: V ←V ∪{s(α), t(α)} 6: A ←A ∪{α} 7: V ˆp ←(s(α), t(α)) ▷Create ˆp via V ˆp 8: P ←P ∪{ˆp} 9: for p ∈P pre do 10: for p′ ∈P post do 11: if V p ∩V p′ = ∅then ▷Prohibit Cycles 12: V New_P ath ←V p ∪V p′ ▷Create New_Path via V New_P ath 13: if New_Path is valid given A then 14: P ←P ∪{New_Path} 15: end if 16: end if 17: end for 18: end for 19: return G, P There can be many definitions for TS, and identifying the “best” definition is orthogonal to the focus of the present paper. Since any “good” definitions can be incorporated into AutoCRAT in a plug-and-play fashion, we will use one example definition to demonstrate the idea. In this example definition of TS, we define it as the geometric mean of the number and diversity of alerts in a set, in order to estimate the risk posed by the associated attacks. This definition can be naturally extended to specify the TS of a pair of endpoints (Endpoint Threat Score — ETS) or a path (Path Threat Score — PTS). Specifically, we have: Definition 5 (Threat Score (TS)). The TS of a set of alerts is defined as: TS(A) = p |{σ ∈ΣA : (∃α ∈A), σ = ℓID(α)}| · |{α ∈A}|. (1) The ETS of an endpoint pair (source, destination) can be calculated as TS({α ∈ A : s(α) = source∧t(α) = destination}). The PTS of a path p can be calculated as TS(Ap). In order to identify the endpoints and paths in the database with the highest threat, AutoCRAT must periodically update ETS and PTS for endpoints and paths, respectively. In order to do this, the defender submits an update query on demand. The update function is simple: first, it calculates ETS for every endpoint object, then it calculates PTS for every path. To reduce the number of accesses to the database, a copy of each endpoint object’s arc annotations is cached during the ETS calculations, in order to facilitate the PTS calculations. The runtime of this approach is based on the following: (i) calculating ETS for all endpoints requires the parsing of each arc (which each belong to exactly one endpoint annotation), meaning the runtime of updating is in Ω(|A|); (ii) calculating PTS for all paths requires the parsing of each endpoint object a number of times equal to the number of paths in which it appears. This is analyzed in Table 3, which shows that the worst case number of appearances of an endpoint object in the set of paths is in O(|E2|). Since there are |E| endpoint objects, this results in a worst-case combined runtime in O(|A| + |E|3). Endpoint i Insertion 1 2 3 4 5 |E| 1 1 2 3 4 5 |E| 2 0 2 4 6 8 2 · (|E| −1) 3 0 0 3 6 9 3 · (|E| −2) 4 0 0 0 4 8 4 · (|E| −3) 5 0 0 0 0 5 5 · (|E| −4) |E| 0 0 0 0 0 |E| i 0 0 0 0 0 i · (|E| −i + 1) Table 3. The worst-case number of paths that contain a particular endpoint. The ith endpoint can only belong to i·(|E|−i+1) = i·|E|−i2 +i paths. Then the worst-case is in O(|E|2) , and the worst-case number of endpoint objects across the set of all paths is P|E| i=1 i · (|E| −i + 1) = 1 6|E|(|E| + 1)(|E| + 2) or O(|E|3). ETS is also used in the visualization of attack paths. Specifically, the color of an alert tree node n represents the normalized ETS of (parent(n), n) for forward trees or (n, parent(n)) for backward trees. Vertex colors range from red to black, where the vertex in the tree with the highest ETS is red and the root is black (along with any other vertices with ETS = 1). In RGB (i.e., hexadecimal) notation, colors range from 0x000000 (black) to 0xFF0000 (red), such that colors may be compared ordinally to mimic the comparison of ETS. This is demonstrated in Figure 2, showing the value of the ETS measurement in presenting salient information to the defender. 59.41.236.38-FWD 172.31.65.75 172.31.0.2 Fig. 2. Example alert tree coloring, where the root is black, the child is red (ETS 179.10), and the grandchild is very nearly black (color code 0x0D0000 and ETS 10.49). Core Module 4: Path Retrieval. Path retrieval requires that the graph and path databases are properly maintained. The path retrieval process then involves a simple query to the database, which stores each path individually. This query leverages the (source, destination) compound index, which efficiently retrieves the appropriate paths from the database. The retrieval algorithm executes with a runtime efficiency of O(|P|), where P ⊆P(A) is the set of paths to be retrieved. Core Module 5: Tree Reconstruction. Tree reconstruction is to reassemble paths into a tree which represents either the attack surface exposed to an attacker or the attack vectors exposing a target, depending on the type of query. In either case, the user must specify a node to act as the root of the tree and the tree’s direction, and the module handles the rest. The tree reconstruction algorithm takes as input a reference node to act as the tree’s root, a direction (i.e., forward or backward), G, and P. It begins by selecting all paths which have the reference node as their origin (for forward trees) or target (for backward trees), using the approach described above. It then parses each path, adding each edge as a node of the tree if it was not already added from a previous path. The worst-case scenario for the tree reconstruction algorithm is the same as the insert algorithm as discussed above, in which each subsequent alert produces a new endpoint which extends that of the previous alert. Specifically, we have at most |E| paths rooted at a given node, and the maximum path length is |E|. This results in a final worst-case runtime of O(|E|2). 4 Case Study Our experiments were run using Ubuntu 20.04 with 192GB of RAM, 2 cores of an Intel Xeon Gold 6242 CPU @2.80 GHz, and a 200GB HDD. These resources were shared among AutoCRAT functions and the corresponding MongoDB database, which was installed on the same computer to eliminate variability imposed by network conditions. 4.1 Dataset The dataset was published by the University of New Brunswick, and is referred to as CSE-CIC-IDS2018 [51]. It contains data collected over the course of 9 days, during which multiple distinct attack scenarios were executed against the net- work. The environment was connected to the internet during the experiments, thus real-world attacks can also be observed in the data. We preprocessed the packet capture (PCAP) files in the dataset using Suricata 4.0 [1] with the cor- responding Emerging Threats signature set [2], to produce a set of 3,323,426 alerts, of which 19,921 were strictly internal to the target network as defined by the dataset authors. We converted the alerts into JSON objects to conform to AutoCRAT’s expected format, and sorted them chronologically before feeding them into the database. 4.2 Experimental Results Database construction for CSE-CIC-IDS2018 took 35h14m07s, resulting in 1,053,710 edges and 3,591,217 paths. Efficiency and accuracy (in terms of graph coverage, which may impose false negatives) are analyzed relative to an existing model, APIN [19]. Path selection for APIN was done using its relevant heuristics. The comparison is shown in Table 4. [19] AutoCRAT Build DB 29m43s 13h42m41s Rank Objects* 49s 1h00m29s Top 100 paths 52s† 32ms Top 20 trees 52s† 2m42s† Coverage (nodes) 99.6% 100% Coverage (events) 3.4% 100% DB size 637 MB 1.1 GB Table 4. Comparison of the proposed AutoCRAT model with an existing model [19]. Query runtimes are the average of 10 runs. Improvements shown in bold. *[19] only ranks nodes, while AutoCRAT scores endpoints and paths. †The models do not directly rank these objects, so they are selected based on applicable node and edge rankings. These inherited rankings may not be accurate with respect to other metrics but offer a reasonable baseline. Note that [19] sacrifices coverage in order to improve runtime. This is neces- sary because its tree retrieval time suffers extraordinary slowdown in the presence of highly connected nodes. Even though [19] only excludes .4% of the vertices in the graph, 96.6% of the arcs in the graph are adjacent to these vertices, and are effectively blacklisted from tree reconstruction, meaning that the set of paths (and trees) that can be reconstructed is incomplete. In AutoCRAT, the con- nectedness slowdown problem is solved by shifting the bulk of the work into the pre-processing stage. This results in a much faster path retrieval time and full graph coverage at the cost of maintenance time. However, this pre-processing time remains feasible in practice since 9 days of data (constituting approxi- mately 164 hours of activity) are processed in under 14 hours. Graph coverage is important because low coverage induces false negatives in the path and tree reconstruction. This means that the model in [19] is vulnerable to DoS attacks, which may allow an attacker to conceal their attack paths by creating so much traffic around a key node that the algorithm removes it from the analysis entirely. In order to compare the two models under comparable conditions, we ran both models again using a reduction of the original dataset, which filtered nodes outside the network as well as edges which crossed the border of the network. This resulted in only 1,994 edges and 3,019 paths, as shown in Table 5. This resulted in a coverage of 0.6% for both nodes and paths, much closer to that of [19] (i.e., roughly 1/6). Given the intuition that internal nodes are far more relevant to defenders, we do not consider the loss of node coverage important in this case (although some of the nodes filtered by [19] were in fact internal nodes). This reduction greatly improved the performance of AutoCRAT, resulting in runtimes and storage efficiency that far outperformed [19]. The above discussion demonstrates trade-offs between pre- and post- pro- cessing times and between processing time and accuracy. [19]-internal AutoCRAT-internal Build DB 9s 35s Rank Objects* 0.28s 5s Top 100 paths 3s† 23ms Top 20 trees 3s† 1.97s† Coverage (nodes) 0.6% 0.6% Coverage (events) 0.6% 0.6% DB size 2.9 MB 2.4 MB Table 5. Comparison of the proposed AutoCRAT model with an existing model [19], using only the internal events. Query runtimes are the average of 10 runs. Improvements shown in bold. *[19] only ranks nodes, while AutoCRAT ranks endpoints and paths. †The models do not directly rank these objects, so they are selected based on applicable node or endpoint rankings. These inherited rankings may not be consistent with respect to other metrics but offer a reasonable baseline. Insight 1 To attain the same accuracy, AutoCRAT (relative to [19]) front-loads its processing time into building and maintaining paths so that when it comes time to retrieve them, it can do so more quickly. For both models, reducing the volume of data processed improves both processing time and database size, but sacrifices accuracy (as measured by coverage). 2.187.100.84-FWD 172.31.65.125 172.31.64.112 172.31.66.101 172.31.0.2 172.31.0.2 (1) 52.87.201.4 54.172.47.69 Fig. 3. A forward tree containing eight vertices, colored red to black based on normal- ized ETS, descending. Of the four leaves (i.e., path targets), the reddest vertex, which represents the endpoints (172.31.66.101, 52.87.201.4) scored an ETS of 5.92 with 35 alerts sharing a single ID. To demonstrate how the alert tree structure and threat score heuristic may be useful in practice, we include example forward and backward trees in Figures 3 and 4, respectively. These trees were selected for their size; some trees produced had well over 1000 vertices and would not be legible in the present format. This problem is a challenge that we leave to future work, as the present focus is efficiency of reconstruction. Answering RQ1. In order to answer RQ1, we must retrieve a set of paths corresponding to a known attack origin and a known attack target. Assum- ing the database maintenance has kept up with the alert stream, this can be accomplished with a query to the database utilizing the (source, destination) index. Because subpaths are also stored in the database, we can be confident 92.45.52.78-BWD 172.31.66.22 172.31.64.54 123.249.24.175 186.95.228.126 47.91.158.245 92.63.197.12 5.188.11.25 Fig. 4. A backward tree containing eight verticess, colored red to black based on nor- malized ETS, descending. Of the six leaves (i.e., path origins), the reddest vertex, which represents the endpoints (92.63.197.12, 172.31.66.22) scored an ETS of 7.35 with 54 alerts sharing a single ID. that we need only retrieve paths that start and end with the origin and target, respectively. This efficiently returns a list containing exactly the required cor- responding paths, without the need to parse the paths to truncate them at the proper destination. Answering RQ2. To answer RQ2, we must reconstruct the forward alert tree corresponding to a particular origin. This process begins with retrieving all of the paths beginning at the specified node, leveraging the source index. We then pass these paths to the tree reconstruction function, which arranges them based on their relationships to each other. Answering RQ3. In order to answer RQ3, we must reconstruct the backward alert tree corresponding to a particular target. Similar to RQ2, this process retrieves the appropriate paths from the database and passes them to the tree reconstruction function. 5 Limitations We identify six limitations that should be addressed in future studies. First, AutoCRAT depends on IDS correctness, meaning that IDS false positives and false negatives can result in errors in AutoCRAT’s path and tree reconstruc- tion. However, in the case where errors occur along paths with true positives, the penalty will only reduce the accuracy of the threat score calculations. It is important to build metrics to quantify the impact of IDS (in)correctness on the trustworthiness of the results, in a fashion similar to [7]. In particular, it would be exciting to establish a systematic quantitative methodology that can be seamlessly incorporated into the Cybersecurity Dynamics framework [66,62] to enable not only reactive defenses but more importantly proactive and adap- tive defenses [32,63,65,61,64,23,72,73,33,24], by possibly leveraging data-driven cyber threats forecasting techniques [53,15,45,60,44,59,69,68]. Second, AutoCRAT assumes that attacks are always initiated by a malicious node. This assumption may be violated in client-side attacks, such as drive-by downloads [47,57,58]. In such cases, an advanced security device may be able to reverse the order of nodes in the alert during preprocessing, preserving attack semantics. It is important to investigate how to extend AutoCRAT to accom- modate cyber social engineering attacks and defenses as they are often used as a means to penetrate into a network, especially in relation to the psychological aspect [35,36,34,49]. It is also interesting to extend AutoCRAT to smart homes, which is an emerging field especially from the cyber insurance perspective [71]. Third, AutoCRAT depends on the accuracy of threat scores. This limitation may result in rankings that do not reliably show the importance of a path or tree relative to the mission at hand. However, it does not affect the accuracy of path or tree reconstruction. Regardless, AutoCRAT can be easily adapted to incorporate better ranking methods, which may include asset values and risk scores. The problem of ranking alerts also remains an open research problem independent of alert path and tree modeling. Thus, we need to develop a systematic family of metrics [43,9,10,14,39,67]. Fourth, AutoCRAT’s path maintenance algorithm assumes that events are inserted sequentially. This means that it may be difficult to parallelize its ex- ecution. Since parallelization is a powerful tool of efficiency, this problem may impact viability of the methods in practice. However, it may be possible to parallelize some alert insertions if the adjacent nodes are disparate relative to sequential alerts. We leave this investigation to future work. Fifth, AutoCRAT assumes that each computer has a single, unique, and static address. It may be extensible to accommodate computers with multiple IP addresses (e.g., by aliasing node names before inserting them into the database or when preprocessing alerts). In the case of a segmented network with private subnets, some computers on disparate subnets may have matching addresses (e.g., 192.168.1.1). This case may be harder to accommodate. Sixth, the efficiency of the path maintenance algorithm depends on the as- sumption that the database is capable of efficiently indexing elements of an array. This restricts the interoperability of the framework to certain kinds of databases. 6 Conclusion We have introduced the AutoCRAT system for modeling and tracking multi-step network attacks as indicated by alerts generated by security devices. The key concepts behind AutoCRAT are those of alert graphs, alert paths, and alert trees. The technical contributions include data structures and algorithms for efficiently representing and constructing alert paths and alert trees, as well as asymptotic storage and runtime complexity analysis. This study is useful to cyber defenders because it quantifies threats against a network and its components and presents them in an intuitive form that is easy to understand. Our case study based on an implementation of AutoCRAT and a research dataset shows that AutoCRAT can efficiently reproduce alert paths and trees, keeping pace with alerts produced on a testbed network. The paper is a significant step towards automating cyber triage with and risk quantification, which remains an important and elusive problem. More research needs to be conducted with real-world datasets, including cyber- physical systems such as smart homes and hospitals. Acknowledgement. We thank the reviewers for their comments. This research was supported in part by NSF Grant #2115134 and Colorado State Bill 18-086. This research used the Chameleon testbed. References 1. Suricata | open source ids / ips / nsm engine. https://suricata-ids.org/ download/ (2018) 2. Welcome to the emerging threats rule server. https://rules.emergingthreats. net/ (2019) 3. Alsubhi, K., Aib, I., Boutaba, R.: Fuzmet: A fuzzy-logic based alert prioritization engine for intrusion detection systems. International Journal of Network Manage- ment 22(4), 263–284 (2012) 4. Apruzzese, G., Pierazzi, F., Colajanni, M., Marchetti, M.: Detection and threat prioritization of pivoting attacks in large networks. IEEE Transactions on Emerging Topics in Computing 8(2), 404–415 (2017) 5. Axelsson, S.: The base-rate fallacy and the difficulty of intrusion detection. ACM Transactions on Information and System Security (TISSEC) 3(3), 186–205 (2000) 6. Chen, C.M., Guan, D., Huang, Y.Z., Ou, Y.H.: Attack sequence detection in cloud using hidden markov model. In: 2012 seventh asia joint conference on information security. pp. 100–103. IEEE (2012) 7. Chen, H., Cho, J., Xu, S.: Quantifying the security effectiveness of firewalls and dmzs. In: Proc. HoTSoS’2018. pp. 9:1–9:11 (2018) 8. Chen, Y., Boehm, B., Sheppard, L.: Value driven security threat modeling based on attack path analysis. In: 2007 40th Annual Hawaii International Conference on System Sciences (HICSS’07). pp. 280a–280a. IEEE (2007) 9. Cho, J., Hurley, P., Xu, S.: Metrics and measurement of trustworthy systems. In: Proc. IEEE MILCOM (2016) 10. Cho, J.H., Xu, S., Hurley, P.M., Mackay, M., Benjamin, T., Beaumont, M.: Stram: Measuring the trustworthiness of computer-based systems. ACM Comput. Surv. 51(6), 128:1–128:47 (2019) 11. Chou, D., Jiang, M.: Data-driven network intrusion detection: A taxonomy of challenges and methods. arXiv preprint arXiv:2009.07352 (2020) 12. Cinque, M., Della Corte, R., Pecchia, A.: Contextual filtering and prioritization of computer application logs for security situational awareness. Future Generation Computer Systems 111, 668–680 (2020) 13. De Alvarenga, S.C., Barbon Jr, S., Miani, R.S., Cukier, M., Zarpelão, B.B.: Process mining and hierarchical clustering to help intrusion alert visualization. Computers & Security 73, 474–491 (2018) 14. Du, P., Sun, Z., Chen, H., Cho, J.H., Xu, S.: Statistical estimation of malware detection metrics in the absence of ground truth. IEEE T-IFS 13(12), 2965–2980 (2018) 15. Fang, Z., Xu, M., Xu, S., Hu, T.: A framework for predicting data breach risk: Leveraging dependence to cope with sparsity. IEEE T-IFS 16, 2186–2201 (2021) 16. Fernandez, G.C., Xu, S.: A case study on using deep learning for network intrusion detection. In: 2019 IEEE Military Communications Conference (MILCOM’2019). pp. 1–6 (2018) 17. Ficke, E., Bateman, R.M., Xu, S.: Reducing intrusion alert trees to aid visualiza- tion. In: Yuan, X., Bai, G., Alcaraz, C., Majumdar, S. (eds.) Network and System Security - 16th International Conference, NSS 2022, Denarau Island, Fiji, Decem- ber 9-12, 2022, Proceedings. Lecture Notes in Computer Science, vol. 13787, pp. 140–154. Springer (2022) 18. Ficke, E., Schweitzer, K.M., Bateman, R.M., Xu, S.: Analyzing root causes of intrusion detection false-negatives: Methodology and case study. In: Proc. IEEE MILCOM’2019 (2019) 19. Ficke, E., Xu, S.: Apin: Automatic attack path identification in computer networks. In: IEEE ISI 2020 (2020) 20. FireEye: The numbers game: How many alerts is too many to handle? https://www.fireeye.com/offers/rpt-idc-numbers-game-special-report.html (2015) 21. Frigault, M., Wang, L.: Measuring network security using bayesian network-based attack graphs. In: 2008 32nd Annual IEEE International Computer Software and Applications Conference. pp. 698–703 (July 2008). https://doi.org/10.1109/ COMPSAC.2008.88 22. Haas, S., Fischer, M.: Gac: graph-based alert correlation for the detection of dis- tributed multi-step attacks. In: Proceedings of the 33rd Annual ACM Symposium on Applied Computing. pp. 979–988 (2018) 23. Han, Y., Lu, W., Xu, S.: Characterizing the power of moving target defense via cyber epidemic dynamics. In: HotSoS. pp. 1–12 (2014) 24. Han, Y., Lu, W., Xu, S.: Preventive and reactive cyber defense dynamics with ergodic time-dependent parameters is globally attractive. IEEE TNSE 8(3), 2517– 2532 (2021) 25. Hossain, M.N., Milajerdi, S.M., Wang, J., Eshete, B., Gjomemo, R., Sekar, R., Stoller, S., Venkatakrishnan, V.: {SLEUTH}: Real-time attack scenario recon- struction from {COTS} audit data. In: 26th {USENIX} Security Symposium ({USENIX} Security 17). pp. 487–504 (2017) 26. Howard, M., Pincus, J., Wing, J.M.: Measuring relative attack surfaces. In: Com- puter security in the 21st century, pp. 109–137. Springer (2005) 27. Hu, H., Zhang, H., Yang, Y.: Security risk situation quantification method based on threat prediction for multimedia communication network. Multimedia Tools and Applications 77(16), 21693–21723 (2018) 28. Hutchins, E.M., Cloppert, M.J., Amin, R.M.: Intelligence-driven computer network defense informed by analysis of adversary campaigns and intrusion kill chains. In: 2011 International Conference on Information Warfare and Security (2011) 29. Khraisat, A., Gondal, I., Vamplew, P., Kamruzzaman, J.: Survey of intrusion detec- tion systems: techniques, datasets and challenges. Cybersecurity 2(1), 1–22 (2019) 30. Lee, S., Kim, S., Choi, K., Shon, T.: Game theory-based security vulnerability quantification for social internet of things. Future Generation Computer Systems 82, 752–760 (2018) 31. Leitold, F., Arrott, A., Hadarics, K.: Quantifying cyber-threat vulnerability by combining threat intelligence, it infrastructure weakness, and user susceptibility. In: 24th Annual EICAR Conference, Nuremberg, Germany (2016) 32. Li, X., Parker, P., Xu, S.: A stochastic model for quantitative security analyses of networked systems. IEEE TDSC 8(1), 28–43 (2011) 33. Lin, Z., Lu, W., Xu, S.: Unified preventive and reactive cyber defense dynamics is still globally convergent. IEEE/ACM ToN 27(3), 1098–1111 (2019) 34. Longtchi, T., Rodriguez, R.M., Al-Shawaf, L., Atyabi, A., Xu, S.: Internet-based social engineering psychology, attacks, and defenses: A survey. Proceedings of IEEE 112(3), 210–246 (2024) 35. Longtchi, T., Xu, S.: Characterizing the evolution of psychological factors exploited by malicious emails. In: Proceedings of International Conference on Science of Cyber Security (SciSec’2024) (2024) 36. Longtchi, T., Xu, S.: Characterizing the evolution of psychological tactics and tech- niques exploited by malicious emails. In: Proceedings of International Conference on Science of Cyber Security (SciSec’2024) (2024) 37. Mandiant: Apt1 report. https://www.fireeye.com/content/dam/fireeyewww/ services/pdfs/mandiant-apt1-report.pdf (2013) 38. Mao, B., Liu, J., Lai, Y., Sun, M.: Mif: A multi-step attack scenario reconstruction and attack chains extraction method based on multi-information fusion. Computer Networks 198, 108340 (2021) 39. Mireles, J., Ficke, E., Cho, J., Hurley, P., Xu, S.: Metrics towards measuring cyber agility. IEEE Transactions on Information Forensics and Security 14(12), 3217– 3232 (2019) 40. Ning, P., Cui, Y., Reeves, D.S.: Constructing attack scenarios through correlation of intrusion alerts. In: Proceedings of the 9th ACM Conference on Computer and Communications Security. pp. 245–254 (2002) 41. Ning, P., Xu, D.: Learning attack strategies from intrusion alerts. In: Proceedings of the 10th ACM conference on Computer and communications security. pp. 200–209 (2003) 42. Ou, X., Boyer, W.F., McQueen, M.A.: A scalable approach to attack graph gener- ation. In: Proceedings of the 13th ACM conference on Computer and communica- tions security. pp. 336–345 (2006) 43. Pendleton, M., Garcia-Lebron, R., Cho, J.H., Xu, S.: A survey on systems security metrics. ACM Comput. Surv. 49(4), 62:1–62:35 (Dec 2016) 44. Peng, C., Xu, M., Xu, S., Hu, T.: Modeling and predicting extreme cyber attack rates via marked point processes. Journal of Applied Statistics 44(14), 2534–2563 (2017) 45. Peng, C., Xu, M., Xu, S., Hu, T.: Modeling multivariate cybersecurity risks. Journal of Applied Statistics 0(0), 1–23 (2018) 46. Phillips, C., Swiler, L.P.: A graph-based system for network-vulnerability analysis. In: Proceedings of the 1998 workshop on New security paradigms. pp. 71–79 (1998) 47. Pritom, M., Xu, S.: Supporting law-enforcement to cope with blacklisted websites: Framework and case study. In: IEEE CNS’2022 (2022) 48. Ramaki, A.A., Rasoolzadegan, A., Bafghi, A.G.: A systematic mapping study on intrusion alert analysis in intrusion detection systems. ACM Computing Surveys (CSUR) 51(3), 1–41 (2018) 49. Rodriguez, R.M., Xu, S.: Cyber social engineering kill chain. In: Proceedings of International Conference on Science of Cyber Security (SciSec’2022). pp. 487–504 (2022) 50. Security, I.: Cost of a data breach report 2021. https://www.ibm.com/downloads/ cas/OJDVQGRY (July 2021) 51. Sharafaldin, I., Lashkari, A.H., Ghorbani, A.A.: Toward generating a new intrusion detection dataset and intrusion traffic characterization. In: ICISSP. pp. 108–116 (2018) 52. Strom, B.: Att&ck 101: Cyber threat intelligence (2018), https://www.mitre.org/ capabilities/cybersecurity/overview/cybersecurity-blog/attck-101 53. Sun, Z., Xu, M., Schweitzer, K., Bateman, R., Kott, A., Xu, S.: Cyber attacks against enterprise networks: Characterization, modeling and forecasting. In: Proc. of SciSec’2023 (2023) 54. Thakkar, A., Lohiya, R.: A review of the advancement in intrusion detection datasets. Procedia Computer Science 167, 636–645 (2020) 55. Vasilomanolakis, E., Cordero, C.G., Milanov, N., Mühlhäuser, M.: Towards the creation of synthetic, yet realistic, intrusion detection datasets. In: NOMS 2016- 2016 IEEE/IFIP Network Operations and Management Symposium. pp. 1209– 1214. IEEE (2016) 56. Wang, X., Gong, X., Yu, L., Liu, J.: Maac: Novel alert correlation method to detect multi-step attack. In: 2021 IEEE 20th International Conference on Trust, Security and Privacy in Computing and Communications (TrustCom). pp. 726–733. IEEE (2021) 57. Xu, L., Zhan, Z., Xu, S., Ye, K.: An evasion and counter-evasion study in malicious websites detection. In: IEEE CNS. pp. 265–273 (2014) 58. Xu, L., Zhan, Z., Xu, S., Ye, K.: Cross-layer detection of malicious websites. In: ACM CODASPY’13. pp. 141–152 (2013) 59. Xu, M., Hua, L., Xu, S.: A vine copula model for predicting the effectiveness of cyber defense early-warning. Technometrics 59(4), 508–520 (2017) 60. Xu, M., Schweitzer, K.M., Bateman, R.M., Xu, S.: Modeling and predicting cyber hacking breaches. IEEE T-IFS 13(11), 2856–2871 (2018) 61. Xu, M., Xu, S.: An extended stochastic model for quantitative security analysis of networked systems. Internet Mathematics 8(3), 288–320 (2012) 62. Xu, S.: The cybersecurity dynamics way of thinking and landscape (invited paper). In: ACM Workshop on Moving Target Defense (2020) 63. Xu, S., Lu, W., Xu, L.: Push- and pull-based epidemic spreading in networks: Thresholds and deeper insights. ACM TAAS 7(3) (2012) 64. Xu, S., Lu, W., Xu, L., Zhan, Z.: Adaptive epidemic dynamics in networks: Thresh- olds and control. ACM TAAS 8(4) (2014) 65. Xu, S., Lu, W., Zhan, Z.: A stochastic model of multivirus dynamics. IEEE Trans- actions on Dependable and Secure Computing 9(1), 30–45 (2012) 66. Xu, S.: Cybersecurity dynamics: A foundation for the science of cybersecurity. In: Lu, Z., Wang, C. (eds.) Proactive and Dynamic Network Defense, vol. 74, pp. 1–31. Springer Nature Switzerland AG (2019) 67. Xu, S.: Sarr: A cybersecurity metrics and quantification framework. In: Third In- ternational Conference on Science of Cyber Security (SciSec’2021). pp. 3–17 (2021) 68. Zhan, Z., Xu, M., Xu, S.: Characterizing honeypot-captured cyber attacks: Statis- tical framework and case study. IEEE Transactions on Information Forensics and Security 8(11), 1775–1789 (2013) 69. Zhan, Z., Xu, M., Xu, S.: Predicting cyber attack rates with extreme values. IEEE Transactions on Information Forensics and Security 10(8), 1666–1677 (2015) 70. Zhang, K., Zhao, F., Luo, S., Xin, Y., Zhu, H.: An intrusion action-based ids alert correlation analysis and prediction framework. IEEE Access 7, 150540–150551 (2019) 71. Zhang, X., Xu, M., Xu, S.: Smart home cyber insurance pricing. In: Proceedings of International Conference on Science of Cyber Security (SciSec’2024) (2024) 72. Zheng, R., Lu, W., Xu, S.: Active cyber defense dynamics exhibiting rich phenom- ena. In: Proc. HotSoS (2015) 73. Zheng, R., Lu, W., Xu, S.: Preventive and reactive cyber defense dynamics is globally stable. IEEE TNSE 5(2), 156–170 (2018)